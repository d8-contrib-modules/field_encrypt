<?php
/**
 * @file
 * Contains module hooks for field_encrypt.
 */

use Drupal\Core\Form\FormStateInterface;

/**
 * Implements hook_form_alter().
 *
 * Adds settings to the field storage configuration forms to allow setting the
 * encryption state.
 */
function field_encrypt_form_alter(&$form, FormStateInterface $form_state, $form_id) {

  // If this is the add or edit form for field_storage, we call our function.
  if (in_array($form_id, ['field_storage_add_form', 'field_storage_config_edit_form'])) {

    // Check permissions.
    $user = \Drupal::currentUser();

    if ($user->hasPermission('administer field encryption')) {
      /* @var $field \Drupal\field\Entity\FieldStorageConfig */
      $field = $form_state->getFormObject()->getEntity();
      $field_type = $field->getType();
      $default_properties = \Drupal::config('field_encrypt.settings')->get('default_properties');

      // Add container for field_encrypt specific settings.
      $form['field_encrypt'] = array(
        '#type' => 'details',
        '#title' => t('Field encryption'),
        '#open' => TRUE,
      );

      $form['field_encrypt']['field_encrypt'] = array(
        '#type' => 'container',
        '#tree' => TRUE,
      );

      // Add setting to decide if field should be encrypted.
      $form['field_encrypt']['field_encrypt']['encrypt'] = [
        '#type' => 'checkbox',
        '#title' => t('Encrypt field'),
        '#description' => t('Makes the field storage encrypted.'),
        '#default_value' => $field->getThirdPartySetting('field_encrypt', 'encrypt', FALSE),
      ];

      $properties = [];
      $definitions = $field->getPropertyDefinitions();
      foreach ($definitions as $property => $definition) {
        $properties[$property] = $definition->getLabel();
      }

      $form['field_encrypt']['field_encrypt']['properties'] = [
        '#type' => 'checkboxes',
        '#title' => t('Properties'),
        '#description' => t('Specify the field properties to encrypt.'),
        '#options' => $properties,
        '#default_value' => $field->getThirdPartySetting('field_encrypt', 'properties', $default_properties[$field_type]),
        '#states' => [
          'visible' => [
            ':input[name="field_encrypt[encrypt]"]' => array('checked' => TRUE),
          ],
        ],
      ];

      $encryption_profile_manager = \Drupal::service('encrypt.encryption_profile.manager');
      $form['field_encrypt']['field_encrypt']['encryption_profile'] = array(
        '#type' => 'select',
        '#title' => t('Encryption profile'),
        '#description' => t('Select the encryption profile to use for encrypting this field.'),
        '#options' => $encryption_profile_manager->getEncryptionProfileNamesAsOptions(),
        '#default_value' => $field->getThirdPartySetting('field_encrypt', 'encryption_profile', FALSE),
        '#states' => [
          'visible' => [
            ':input[name="field_encrypt[encrypt]"]' => array('checked' => TRUE),
          ],
        ],
      );

      // We add a function to process the form when it is saved.
      $form['#entity_builders'][] = 'field_encrypt_form_field_add_form_builder';
    }
  }
}

/**
 * Update the field storage configuration to set the encryption state.
 *
 * @param string $entity_type
 *   The entity type.
 * @param \Drupal\field\Entity\FieldStorageConfig $fieldStorageConfig
 *   The field storage config entity.
 * @param array $form
 *   The complete form array.
 * @param \Drupal\Core\Form\FormStateInterface $form_state
 *   The current state of the form.
 */
function field_encrypt_form_field_add_form_builder($entity_type, \Drupal\field\Entity\FieldStorageConfig $fieldStorageConfig, &$form, \Drupal\Core\Form\FormStateInterface $form_state) {
  $field_encryption_settings = $form_state->getValue('field_encrypt');
  $form_encryption = $field_encryption_settings['encrypt'];
  $original_encryption = $fieldStorageConfig->getThirdPartySettings('field_encrypt');

  // If the form has the value, we set it.
  if ($form_encryption === 1) {
    foreach ($field_encryption_settings as $settings_key => $settings_value) {
      $fieldStorageConfig->setThirdPartySetting('field_encrypt', $settings_key, $settings_value);
    }
  }
  else {
    // If there is no value, remove third party settings.
    $fieldStorageConfig->unsetThirdPartySetting('field_encrypt', 'encrypt');
    $fieldStorageConfig->unsetThirdPartySetting('field_encrypt', 'properties');
    $fieldStorageConfig->unsetThirdPartySetting('field_encrypt', 'encryption_profile');
  }

  if ($original_encryption !== $fieldStorageConfig->getThirdPartySettings('field_encrypt')) {
    // We need to process the field to either encrypt or decrypt the stored fields if the setting was changed.
    $field_name = $fieldStorageConfig->get('field_name');
    $field_entity_type = $fieldStorageConfig->get('entity_type');

    /**
     * @var $field_encrypt_process_entities \Drupal\field_encrypt\FieldEncryptProcessEntities
     */
    // @TODO: refactor logic for re-encrypting existing fields - currently broken, so commented out.
    //    $field_encrypt_process_entities = \Drupal::service('field_encrypt.process_entities');
    //    if ($form_encryption === 1) {
    //      $field_encrypt_process_entities->encryptStoredField($field_entity_type, $field_name);
    //    }
    //    elseif ($form_encryption === 0) {
    //      $field_encrypt_process_entities->decryptStoredField($field_entity_type, $field_name);
    //    }
  }
}

/**
 * Implements hook_entity_insert().
 *
 * Encrypts the entity after being saved for the first time.
 */
function field_encrypt_entity_insert(Drupal\Core\Entity\EntityInterface $entity) {
  if (($entity instanceof Drupal\field_encrypt\Entity\EncryptedFieldValueInterface)) {
    return;
  }
  // Save the entity again, but now encrypted.
  // @TODO: check if there's not a cleaner way to do this.
  $saved_entity = entity_load($entity->getEntityTypeId(), $entity->id());
  if ($saved_entity) {
    $saved_entity->save();
  }
}

/**
 * Implements hook_entity_presave().
 *
 * Encrypt entity fields before they are saved.
 */
function field_encrypt_entity_presave(\Drupal\Core\Entity\EntityInterface $entity) {
  if (($entity instanceof Drupal\field_encrypt\Entity\EncryptedFieldValueInterface) || !($entity instanceof Drupal\Core\Entity\ContentEntityInterface)) {
    return;
  }

  if (!$entity->isNew()) {
    /* @var $field_encrypt_process_entities \Drupal\field_encrypt\FieldEncryptProcessEntities */
    $field_encrypt_process_entities = \Drupal::service('field_encrypt.process_entities');
    $field_encrypt_process_entities->encryptEntity($entity);
  }
}

/**
 * Implement hook_entity_storage_load().
 *
 * Decrypt entity fields when loading entities.
 */
function field_encrypt_entity_storage_load($entities, $entity_type) {
  /**
   * @var $field_encrypt_process_entities \Drupal\field_encrypt\FieldEncryptProcessEntities
   */
  $field_encrypt_process_entities = \Drupal::service('field_encrypt.process_entities');

  foreach ($entities as &$entity) {
    if (!($entity instanceof Drupal\Core\Entity\ContentEntityInterface)) {
      continue;
    }
    $field_encrypt_process_entities->decryptEntity($entity);
  }
}

/**
 * Implements hook_entity_delete().
 *
 * Remove EncryptedFieldValues associated with this entity.
 */
function field_encrypt_entity_delete(Drupal\Core\Entity\EntityInterface $entity) {
  if (!($entity instanceof Drupal\Core\Entity\ContentEntityInterface)) {
    return;
  }
  $encrypted_field_value_manager = \Drupal::service('field_encrypt.encrypted_field_value_manager');
  $encrypted_field_value_manager->deleteEncryptedFieldValues($entity);
}
